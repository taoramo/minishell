
Features:
	✔ Display a prompt when waiting for a new command. @done(24-01-30 13:47)
	✔ Have a working history. @done(24-01-30 13:47)
	✔ Search and launch the right executable @done(24-01-30 13:47)
		✔ based on the PATH variable @done(24-01-30 13:46)
		✔ using a relative or an absolute path @done(24-01-30 13:47)
	☐ Avoid using more than one global variable to indicate a received signal.
	✔ Not interpret unclosed quotes @done(24-01-30 14:15)
	☐ Not interperet special characters which are not required by the subject such as \ (backslash) or ; (semicolon).
		Should these special characters give an error, or just be treated as normal characters?
	☐ Handle ’ (single quote) which should prevent the shell from interpreting the metacharacters in the quoted sequence.
	☐ Handle " (double quote) which should prevent the shell from interpreting the metacharacters in the quoted sequence except for $ (dollar sign).
	✔ Implement redirections @done(24-01-30 13:51)
		✔ < should redirect input @done(24-01-30 13:51)
		✔ > should redirect output @done(24-01-30 13:51)
		✔ << should be given a delimiter, then read the input until a line containing the delimiter is seen. However, it doesn’t have to update the history! @done(24-01-30 13:51)
		✔ >> should redirect output in append mode @done(24-01-30 13:51)
	✔ Implement pipes (| character). @done(24-01-30 13:52)
	☐ Handle environment variables ($ followed by a sequence of characters) which should expand to their values.
		Has to be done before running command, as environment variable may e.g. contain name of command
	☐ Handle $? which should expand to the exit status of the most recently executed foreground pipeline.
		Could be expanded right before running command / pipe?
	☐ Handle ctrl-C, ctrl-D and ctrl-\ which should BEHAVE LIKE IN BASH (see fixes section)
		✔ ctrl-C displays a new prompt on a new line @done(24-01-30 13:55)
		✔ ctrl-D exits the shell @done(24-01-30 13:55)
		✔ ctrl-\ does nothing @done(24-01-30 13:56)
	<< operators always take input first, even if you have the bonus’ && / || operators it will first take every heredoc’s input that’s on the inputted line and then goes through the multiple cmd pipelines. It is interesting because it’s the only redirection that takes such precedence (trying to be user-friendly? idk)
	ctrl-c and ctrl-d work in their special way during the input taking of the heredoc
	you can have multiple heredocs within one pipeline which means managing multiple temp files


Built-in functions:
	✔ Work for single commands @done(24-02-06 14:35)
	✔ Work in pipes @done(24-02-06 14:35)
	✔ echo with option -n @done(24-02-06 14:35)
	✔ cd with only a relative or absolute path @done(24-02-12 08:54)
	✔ pwd with no options @done(24-02-08 16:29)
	✔ export with no options @done(24-02-08 16:29)
	✔ unset with no options @done(24-02-08 16:29)
	✔ env with no options or arguments @done(24-02-06 14:35)
	☐ exit with no options

Bonus:
	✔ && and || with parenthesis for priorities. @done(24-01-30 13:59)
	✔ Wildcards * should work for the current working directory. @done(24-02-08 16:29)

Fixes:
	✔ When giving a piped command: "syntax error near unexpected token `|’" (probably in function check_cmd_line_syntax) @done(24-02-01 11:07)
		☐ fixed in "check_cmd_line_syntax", check that this change does not break any error checking
	✔ ctrl-D should print "exit" before exiting @done(24-02-05 09:54)
		☐ If we are specific, it should print exit on the same line as minishell prompt
	☐ Error checks everywhere
	☐ Handle exit when command fails correctly (free etc)
	☐ "echo hello &&& echo wow" and "echo hello ||| echo wow" output the first "hello" (should not run at all)
	☐ "echo hello && | echo wow" prints "hello" and "wow" (should fail on '|' at start of command and not run at all)
	☐ "cd tester" "cd .." segfault
	☐ "touch a && chmod 000 a && echo hi > a" should print "minishell: a: Permission denied"
	☐ "echo hi > a | grep h > b > a > c < a" a, b, and c should be empty
	☐ "echo | echo | > echo" segfaults
	☐ below should take input for both heredocs and creates (if they don’t exist yet) and truncates a, b and c -> outputs nothing
	☐ minishell> << LIM > a > b > a >> b | << LIM > c
			> asdf
			> LIM
			zsh: segmentation fault  ./minishell
	☐ export and unset should take multiple args
	☐ export ASDF && export prints two vars on the same line

Unsure:
	☐ << should read the input until a line CONTAINING the delimiter is seen, bash reads until a line ONLY CONTAINING
		currently works as bash does
	☐ export x='$y' | export y=z | echo $x should not change env variables ?? does pipe have own env ?
		since pipe is forked, should run in subshell (random person on internet), so could use env instead of *env
	☐ "‘|’ cat" prints error message twice

Tester:
	☐ Figure out how to test in interactive mode for e.g. "cd" testing

Archived fixes:
	✔ ctrl-C should not print "^C" - have not found a way other than to run "stty -echoctl" to stop the terminal emulator from printing control characters @done(24-02-05 09:54)
	✔ "* hello" in a folder containing only a file named "echo" should work as "echo hello" @done(24-02-12 08:44)
	✔ the argument .. doesn't get to argv, for example "echo .." (or arg .) @done(24-02-12 08:44)
	✔ cd with relative path @done(24-02-12 08:44)
	✔ ft_getenv needs to determine size of returned string, cannot be known before @done(24-02-12 08:44)
	✔ Non matching wildcard pattern should return the pattern @done(24-02-12 08:44)
	✔ should the command 'ec"ho" hello' work? it does in bash @done(24-02-09 08:39)
	✔ Use ft_getenv in add_path as well @done(24-02-12 08:46)
	✔ ft_getenv expands "$HOME*" as it would $HOME, should expand $HOME* (blank output) @done(24-02-12 08:46)
	✔ "./false 1 || ./true 2" - first command returns 1 but second does not run @done(24-01-30 15:09)
	✔ "./false 1 && ./true 2 || ./true 3" stopping after first false @done(24-01-30 15:40)
	✔ "./true 1 && ./false 2 || (./true 3 && ./false 4) || ./false 5 && ./true 6" skipping parentheses @done(24-02-01 10:20)
	✔ Unnecessary "syntax error near unexpected token `(’" in e.g. "awk 'BEGIN { for(i=1;i<=5;i++) print "10 x", i, "is",10*i; }'" @done(24-02-05 09:44)
	✔ export x='$a', export a=hello, echo $x prints "hello", shoud print "$a" and not re-expand expanded result @done(24-02-12 09:32)
